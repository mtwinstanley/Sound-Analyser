/**
 *	ARM-based Real-time Sound Analyser and Classifier
 *
 *	This file contains the initialisation functions for the SD Card interaction
 *
 *  @file		SDCard.c
 *	@author		Matt Winstanley	
 *	@email		mle.winstanley@gmail.com
 *	@ide		Keil uVision 5
 *	@packs		STM32F4xx Keil packs version 2.2.0 or greater required
 *	@stdperiph	STM32F4xx Standard peripheral drivers version 1.4.0 or greater required
 */
#include "stm32f4xx.h"
#include "stm32f4xx_exti.h"
#include "stm32f4xx_syscfg.h"
#include "misc.h"
#include "SDCard.h"
#include "codebook.h"
#include "config.h"
#include "leds.h"
#include "tm_stm32f4_fatfs.h"
#include "tm_stm32f4_usart.h"
#include "tm_stm32f4_rtc.h"
#include <string.h>

/* FATFS related variables */
FATFS fatFs;
FIL file, fil;
FRESULT fres;

/* Read Buffer */
uint8_t SD_Buffer[512];

/* Card Detection */
uint8_t SDCardInserted;

/* Configuration structure definition */
config_type config;

/* RTC */
TM_RTC_Time_t datatime;

/**
  * Configure the Card Detection Pin
  * Name: SDCard_configureCD
  *
  * Description: Configures the card detection pin to generate an interrupt when a change in state is detected
  *              This uses the External Interrupt (EXTI) to handle the interrupt
  *              Then added into the Nested Vector Interrupt Controller (NVIC)
  *
  * Arguments: void
  *
  * Returns: void  
  */
void SDCard_configureCD(){
  EXTI_InitTypeDef EXTI_InitStruct;
  NVIC_InitTypeDef NVIC_InitStruct;
	
  /* Enable clock for SYSCFG */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Tell system that you will use PC7 for EXTI_Line0 */
  SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOC, EXTI_PinSource7);

  /* PC7 is connected to EXTI_Line7 */
  EXTI_InitStruct.EXTI_Line = EXTI_Line7;
  /* Enable interrupt */
  EXTI_InitStruct.EXTI_LineCmd = ENABLE;
  /* Interrupt mode */
  EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;
  /* Triggers on rising and falling edge */
  EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
  /* Add to EXTI */
  EXTI_Init(&EXTI_InitStruct);

  /* Add IRQ vector to NVIC */
  /* PC7 is connected to EXTI_Line7, which has EXTI9_5_IRQn vector */
  NVIC_InitStruct.NVIC_IRQChannel = EXTI9_5_IRQn;
  /* Set priority */
  NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0x00;
  /* Set sub priority */
  NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0x00;
  /* Enable interrupt */
  NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
  /* Add to NVIC */
  NVIC_Init(&NVIC_InitStruct);
}

/**
  * Handle PC7 interrupt
  * Name: EXTI9_5_IRQHandler
  *
  * Description: Handles the interrupt generated by the card detect pin
  *              This sends a debug message with the new status of the SD card
  *              If no SD card is detected, the Error LED function is called
  *              If it is detected then the LED is cleared 
  *
  * Arguments: void
  *
  * Returns: void  
  */
void EXTI9_5_IRQHandler(void) {
  char str[20];
  /* Make sure that interrupt flag is set */
  if (EXTI_GetITStatus(EXTI_Line7) != RESET) {
    if ((((FATFS_USE_DETECT_PIN_PORT)->IDR & (FATFS_USE_DETECT_PIN_PIN)) == 0 ? 0 : 1) != 0 && SDCardInserted == 1) {
      sprintf(str, "NO SD CARD INSERTED\n\r");
      TM_USART_Puts(USART1, str);
      SDCardInserted = 0;
      LED_error();
    }
    if ((((FATFS_USE_DETECT_PIN_PORT)->IDR & (FATFS_USE_DETECT_PIN_PIN)) == 0 ? 0 : 1) == 0 && SDCardInserted == 0) {
      SDCardInserted = 1;
      sprintf(str, "SD CARD INSERTED\n\r");
      TM_USART_Puts(USART1, str);
      LED_clearError();
    }
    /* Clear interrupt flag */
    EXTI_ClearITPendingBit(EXTI_Line7);
  }
}

/**
  * Read the configuration file
  * Name: SDCard_readConfig
  *
  * Description: Mounts the SD card and opens the configuration file
  *              The data in the file is extracted and placed in a buffer
  *              The file is then closed and the SD card unmounted
  *
  * Arguments: void
  *
  * Returns: void  
  */
void SDCard_readConfig() {
  char str[512];
  uint32_t count;

  fres = f_mount(&fatFs, "SD:", 0);
	
  if (fres != FR_OK) {
    sprintf(str, "Error Message @%d\n\r", fres);
    /* Put to USART */
    TM_USART_Puts(USART1, str);
  }
  if ((fres = f_open(&file, "SD:config.txt", FA_READ | FA_WRITE)) != FR_OK){
    if (fres == FR_NO_FILE) {
      sprintf(str, "NO CONFIG FILE AVAILABLE\n\r");
      TM_USART_Puts(USART1, str);
	}
    else {
      sprintf(str, "Failed to open file. Error: %d\n\r", fres);
      TM_USART_Puts(USART1, str);
	}
  }
  else {
    f_read(&file, SD_Buffer, sizeof(SD_Buffer), &count);
    sprintf(str, "Reading is done. Read %d bytes\n\r", count);
    TM_USART_Puts(USART1, str);
    f_close(&file);
    f_mount(NULL, "SD:", 1);
    sprintf(str, "File Contents:\n\r%s", SD_Buffer);
    /* Put to USART */
    TM_USART_Puts(USART1, str);
  }
}

/**
  * Extract data from buffer
  * Name: SDCard_extractConfig
  *
  * Description: Separates the buffer array filled by reading the configuration file using delimiters
  *              Values extracted for each expected parameter
  *              Configuration structure was populated with the extracted values
  *
  * Arguments: void
  *
  * Returns: void  
  */
void SDCard_extractConfig(){
  char str[512];
  char *str1, *str2, *param, *value;
  char *saveptr1, *saveptr2;
  int j;

  for (j=1, str1 = (char *) SD_Buffer; ; j++, str1 = NULL) {
    param = strtok_r(str1, ";", &saveptr1);
    if (param == NULL){
      break;
    }
    for (str2 = param; ; str2 = NULL) {
      value = strtok_r(str2, " = ", &saveptr2);
      if (value == NULL) {
        break;
      }
	  /* Extract Cutoff Frequency */
      if (strstr(value, "Cutoff") != NULL){
        str2 = NULL;
        value = strtok_r(str2, " = ", &saveptr2);
        config.LPF_cutOffFrequency = atoi(value);
      }
	  /* Extract Sampling Frequency */
      else if (strstr(value, "Adc_sampling") != NULL){
        str2 = NULL;
        value = strtok_r(str2, " = ", &saveptr2);
        config.ADC_samplingRate = atoi(value);
      }
	  /* Extract Classification Time */
      else if (strstr(value, "Time") != NULL){
        str2 = NULL;
        value = strtok_r(str2, " = ", &saveptr2);
        config.classificationTime = atoi(value) * config.ADC_samplingRate;
      }
      sprintf(str, "--> %s\n\r", value);
      /* Put to USART */
      TM_USART_Puts(USART1, str);
    }
  }
  sprintf(str, "cut = %u, adc = %u, time = %u\n\r", config.LPF_cutOffFrequency, config.ADC_samplingRate, config.classificationTime);
  /* Put to USART */
  TM_USART_Puts(USART1, str);
}

/**
  * Write data to SD card
  * Name: SDCard_writeData
  *
  * Description: If the SD card is detected, it is mounted and the correct file is opened
  *              The string is created using the time from the RTC, the classification Value and the data 
  *              The file is then appended to include the new line of text
  *
  * Arguments: data_type type - enumerated type to determine what type of data is to be written
  *            uint32_t data[] - data array
  *	           const char * classificationValue - String of classification result
  *
  * Returns: void  
  */
void SDCard_writeData(data_type type, uint32_t data [], const char *classificationValue) {
  char str[codebookSize * codebookSize * 3] = {0}, fileName[14], time[25];
  char contents[codebookSize * codebookSize * 3] = {0};
  uint32_t count;
  uint32_t cnt;
  int i;
  /* Only attempt the write function if SD card is inserted */
  if (SDCardInserted){
    /* Get time and date */ 
    TM_RTC_GetDateTime(&datatime, TM_RTC_Format_BIN);
    sprintf(time, "%02d.%02d.%04d %02d:%02d:%02d    ",
            datatime.date,
            datatime.month,
            datatime.year + 2000,
            datatime.hours,
            datatime.minutes,
            datatime.seconds
            );
    /* Set filename */
    if (type == SMatrix_type){
      sprintf(fileName, "SD:SMatrix.txt");
    }
    /* Mount SD card and open file */
    if ((fres = f_mount(&fatFs, "SD:", 0)) == FR_OK){
	  /* If file does not exist then create it */
      if ((fres = f_open(&fil, fileName, FA_READ | FA_WRITE)) == FR_NO_FILE){
        fres = f_open(&fil, fileName, FA_CREATE_ALWAYS | FA_READ | FA_WRITE);
      }
      /* If file does exist navigate to the end of the file */
      else {
        f_read(&fil, str, sizeof(str), &cnt);
        f_lseek(&fil, cnt);
      }
      if (fres != FR_OK){
        sprintf(str, "Error Message @%d\n\r", fres);
        TM_USART_Puts(USART1, str);
      }
      else {
      /* S Matrix data transmission */
      if (type == SMatrix_type){
        /* Populate string with S Matrix values */
        for (i = 0; i < codebookSize; i++){
          if (i == 0) {
            sprintf(contents, "%s%s%u, ", time, classificationValue, ((uint32_t *)data)[i]);
          }
          else if (i == 27) {
            sprintf(contents, "%s%u\n\r", contents, ((uint32_t *)data)[i]);
          }
          else {
            sprintf(contents, "%s%u, ", contents, ((uint32_t *)data)[i]);
          }
        }
        /* Append end of the file */
        count = f_puts(contents, &fil);
        }
        /* Put to USART */
        TM_USART_Puts(USART1, contents);
        sprintf(str, "Writing is done. Written %d bytes. Error = %d\n\r", count, fres);
        TM_USART_Puts(USART1, str);
        f_close(&fil);
        f_mount(NULL, "SD:", 1);
      }
    }
    else {
      sprintf(str, "Error Message @%d\n\r", fres);
      /* Put to USART */
      TM_USART_Puts(USART1, str);
    }
  }
}
